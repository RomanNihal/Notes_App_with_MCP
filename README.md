# Backend Engineering of the Notes App

This document provides a line-by-line engineering breakdown of the system.

---

## üîå 1. database.py (The Connection Engine)

This file is the "Heart" of your data persistence.

### create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
- The "Engine" is the actual connection pool to the SQLite file.
- SQLite is technically a file-based system. On Windows, if two different Python "threads" (FastAPI tasks) try to talk to the same file at once, SQLite gets scared and crashes. 
- "check_same_thread": False tells SQLite: "Trust me, I am using a modern web framework that handles concurrency safely."

### sessionmaker(autocommit=False, autoflush=False)
- Think of the "Engine" as the pipes, and the "Session" as the water coming out.
- autocommit=False: This is critical. It means nothing is saved to the disk until we explicitly say `db.commit()`. This allows us to undo (rollback) if an error happens halfway through.
- autoflush=False: Prevents the database from trying to "predict" and save changes before we are ready.

### def get_db(): (The Generator Pattern)
- This uses the Python `yield` keyword.
- When a request comes in, the function runs until `yield db`. It pauses there and "lends" the connection to the API.
- Once the API finishes sending the response, the function resumes and runs `db.close()`.
- This ensures we never leak memory or leave the database file "locked."

---

## üóÉÔ∏è 2. models.py (The Database Blueprint)

This file defines the Object-Relational Mapping (ORM).

### Base = declarative_base()
- This is a "Mapper." It tracks every class that inherits from it and prepares the SQL `CREATE TABLE` commands.

### Column(Integer, primary_key=True, index=True)
- primary_key=True: This makes the ID unique. No two notes can have the same ID.
- index=True: This creates a "B-Tree" index in the background. If you have 1 million notes and search for ID #999,999, the index allows the database to find it instantly without reading every single row from the top.

### Column(DateTime, default=datetime.utcnow)
- Note that we pass the function `datetime.utcnow` WITHOUT parentheses `()`. 
- This tells SQLAlchemy: "Call this function only when a new row is actually created," rather than using the time when the server started.

---

## üõ°Ô∏è 3. schemas.py (The Gatekeeper)

This file uses **Pydantic**, which is the "Security Guard" of your API.

### class NoteCreate(BaseModel)
- This defines what the API *accepts*. By only including `title` and `content`, we prevent a hacker from trying to send a manual `id` or a fake `created_at` timestamp in their request.

### class Config: from_attributes = True
- SQLAlchemy returns "Objects" (Python classes). FastAPI needs to return "JSON" (Dictionaries).
- This line allows Pydantic to look at a Class Object and "extract" the data it needs to turn it into JSON.

---

## üöÄ 4. main.py (The Logic Controller)

### models.Base.metadata.create_all(bind=engine)
- On startup, this checks the `notes.db` file. If the table `notes` doesn't exist, it creates it. This is why you don't need to manually setup a database.

### db: Session = Depends(get_db)
- This is **Dependency Injection**. 
- It tells FastAPI: "Before you run this function, go run `get_db`, give me the session, and name it `db`."
- This makes the code modular. You can swap `get_db` with a "Test Database" easily during development.

### db.refresh(db_note)
- When we save a note, the ID is generated by the database, not by Python.
- `db.refresh` tells Python: "Go back to the database file and fetch the new ID and Timestamp so I can show them to the user."

---

## ü§ñ 5. notes_mcp.py (The AI Bridge)

### @mcp.tool()
- This is a "Decorator." It registers the function into the MCP Server's registry.
- When an AI (like Claude) connects, the MCP server sends a list of these tools to the AI.

### httpx.AsyncClient()
- Why not just use `requests`? 
- `requests` is "Blocking." If one request takes 10 seconds, the whole server stops.
- `httpx` is "Asynchronous." It can send a request and, while waiting for the response, the CPU can work on other tasks. This is how high-performance backend systems handle thousands of users.

### The Decoupling Principle
- Notice that `notes_mcp.py` calls the API via `http://127.0.0.1:8000/notes/`.
- It does **not** import the database.
- This is a "Microservices" mindset. If you ever move your Notes App to a different server, the MCP server only needs to change one URL to keep working.